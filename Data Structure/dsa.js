// Dsa;

// How to calculate time and space complexity?
// Time complexity of quick sort
// Explain memory management?
// What is memory-leak with example?
// Difference between array and linklist?
// Write the code to find the given list is circular linklist?
// Disadvantage of recursion?
// Remove the duplicates from array using recursion?
// Reverse the binary tree
// Find the height of binary tree
// Write the code to check the graph is connected or not?
// Write the code to reverse the string at same place using stack or recursion?
// Find the character occurrence in the given string using hashtable or normal way by maintaining time complexity constraints


// DS
// ---
// sum of elements in an array using recursion
// AVL tree
// monotonic stack & monotonic queue
// reverse a string using queue



// DSA
// - byte
// - circular references 
// - traditional array vs js arrays
// - UTF-8 vs ASCII
// - escape sequences
// - AVL trees
// - weighted graphs 
// - shuffle an array
// - selection sort

// DB
// - covered query
// - redundancy 
// - scaling 
// - explain()
// - reduce the salary of developers by 20%
// - unique skills without using distinct 
// - developers who joined after 2023

// WEEK-15
// -------
// Internal nodes
// Height of Tree
// Spanning tree
// Heapify

// WEEK-14
// -------
// insert sort
// bubble sort
// merge sort
// separate chaining
// Hash Collision
// linear probing
// contracting probing
// hashing vs encryption
// SHA1, MD5, CRC32, other popular hashing algorithms
// hash table
// Time Complexity, 
// Space complexity for sortings, 
// Practices stacks and queues problems.


// WEEK-13
// -------
// memory leak
// dynamic array
// types of linked list
// applications of doubly LL
// Memory leak,Linked list problem (handle edge cases),logN
// Slice,String workout


// binary search and replace target with 0
// merge sort

// -replace all the values of given object with your name 
// -find the second largest word in a sentence 
// -time complexity of quick sort 
// -reverse your name using recursion 





//  Binary search and replace target with 0: Search a sorted array for a target and replace its value with 0.

// Merge sort: A divide-and-conquer sorting algorithm that recursively splits and merges arrays.

// Segment: A data structure for range queries and updates on arrays.

// AVL tree: A self-balancing binary search tree with height balancing.

// Red-black tree: A binary search tree with specific coloring rules to maintain balance.

// Linear probing: Collision resolution technique in hashing using sequential search.

// Quadratic probing: Collision resolution technique with quadratic steps for searching empty slots.

// Heap: A complete binary tree used for priority queues with max/min properties.

// Hash table: Maps keys to values for fast data retrieval using hashing.

// Asymptotic notation: Describes the growth rate of algorithms, e.g., Big O, Θ, Ω.

// Array vs linked list: Arrays have fixed sizes and sequential access; linked lists are dynamic and use pointers.

// Stack vs queue: Stack follows LIFO (Last In First Out); Queue follows FIFO (First In First Out).

// Quick sort: A divide-and-conquer sorting algorithm using pivot-based partitioning.

// Merge sort: Repeated from point 2 (divide and conquer sorting).

// Insertion sort: Simple sorting algorithm by inserting elements in the correct position.

// Tree vs graph: Trees are hierarchical and acyclic; graphs can have cycles and no root.

// Types of trees and graphs: Trees include binary, AVL, red-black; graphs include directed, undirected, weighted.

// Applications of divide and conquer: Used in sorting, searching, and algorithms like quicksort and mergesort.

// Complexity of bubble sort: Worst-case and average-case complexity is O(n²).

// Double hashing: Uses two hash functions for collision resolution in hash tables.

// Backtracking: A method to solve problems by exploring and backtracking when constraints fail.

// Applications of trie: Used for storing words, autocomplete, and prefix matching.

// Cyclic vs loops in graphs: Cyclic graphs contain cycles; loops are self-edges in graphs.

// Complete binary tree: A binary tree where all levels are filled except possibly the last.

// Disadvantages of recursion: Uses extra memory for stack and can lead to stack overflow.

// Applications of doubly linked list: Efficient for operations like insertions, deletions in both directions.

// Load factor: Ratio of entries to the total capacity of a hash table.

// Degree of a node: Number of edges connected to a graph node.

// Collision resolution techniques: Include chaining, linear probing, and double hashing.

// Worst case of quicksort: Occurs when the pivot always picks the smallest or largest element; O(n²).

