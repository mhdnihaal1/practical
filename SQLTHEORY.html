DataBAse : 
It is a structured collection of data in a format that can be easily accessed , inserted , updated and deleted in an efficient and easier way.
A software application used to manage our Database is called DBMS.

- In database we store interrelated datas in the form of tables.

Types of databases:

1.Relational(SQL) : 
 Stored in tables
 We use SQL to work with Relational databases.
 Relation between one or more tables.
Eg: MySql , Oracle , PostgreSQL 

2.Non Relational Databases( Nosql)
It do not follow traditional relational databases , and doesnt use structured schema.
Not stored in tables
They prioritize scalability , flexibility and performance more than ACID properties.
eg:MOngoDG , cassandra ,redis

--------------------------------------------------------------------------------------------------------------------------------------------------
SQL (Structured query language)
It is a programming language which is used to interact with relational databases.
It is used to perform CRUD operations

Columns in the Table gives us design/ structure /schema
Rows represent individual data 
--------------------------------------------------------------------------------------------------------------------------------------------------
PostgresSQL:
It is the actual database engine and SQL is the structured query language.
Object-relational database management system.
Open source and modern.

\l (or \list):
The \l command is used to list all available databases.

\q:
The \q command is used to exit the PostgreSQL interactive terminal and return to the \dtregular command prompt.

Connect to a Database:
\c

List Databases:
\l

List Tables:
\dt

--------------------------------------------------------------------------------------------------------------------------------------------------

CREATE DATABASE test1;
DROP DATABASE test1;
DROP TABLE person;


CREATE TABLE table_name {
	column name + data type + constraints if any
	}
https://www.postgresql.org/docs/11/datatype.html

CREATE TABLE person(
 id INT,
 first_name VARCHAR(50),
 last_name VARCHAR(50),
 gender VARCHAR(6),
 DOB DATE );

\d for seeing all the existing tables


PRIMARY KEY: The primary key uniquely identifies each record in the table, and it must contain unique values (no duplicates). Using BIGSERIAL in combination with PRIMARY KEY is a common pattern for creating auto-incrementing primary key columns.

Creating table by using null and primary key.
CREATE TABLE person (
  id BIGSERIAL NOT NULL PRIMARY KEY,
  first_name VARCHAR(50) NOT NULL,
  last_name VARCHAR(50) NOT NULL,
  gender VARCHAR(6) NOT NULL,
  date_of_birth DATE NOT NULL,
  email VARCHAR(50)
);

--------------------------------------------------------------------------------------------------------------------------------------------------

* How to insert records into table.

INSERT INTO person(
first_name , last_name , gender , date_of_birth , email )
VALUES ( 'Muhammad' , 'Nazim' , 'Male' ,'2001-09-09' , 'nazim@gmail.com');
--------------------------------------------------------------------------------------------------------------------------------------------------

* How to view records from the table.
SELECT * FROM person;
SELECT first_name,gender,email FROM person;     ---------      For multiple columns

--------------------------------------------------------------------------------------------------------------------------------------------------
Creating table from file
 \i /Users/muham/downloads/person.sql;

--------------------------------------------------------------------------------------------------------------------------------------------------
Order by key-word
SELECT * FROM person ORDER BY country_of_birth;
SELECT * FROM person ORDER BY gender;

SELECT * FROM person ORDER BY first_name DESC;   { Descending order }
--------------------------------------------------------------------------------------------------------------------------------------------------
LIMIT:
SELECT * FROM car ORDER BY price DESC LIMIT 5;

--------------------------------------------------------------------------------------------------------------------------------------------------
Distinct : IT will give distinct values.
SELECT DISTINCT country_of_birth FROM person ORDER BY country_of_birth;

--------------------------------------------------------------------------------------------------------------------------------------------------
WHERE: Clause and AND: OR:

SELECT * FROM person WHERE gender = 'Female';

--------------------------------------------------------------------------------------------------------------------------------------------------

Comparison operators:
SELECT 2=2 ;             { It gives true }
SELECT 'AMIGO' = 'AMIGO'; { Gives true}

--------------------------------------------------------------------------------------------------------------------------------------------------
IN:
IN  keywords use an array of keywords and then return the query matching those values ,,{ we can use instead of OR OR OR OR}
 SELECT * FROM person WHERE country_of_birth IN ('China' , 'France' , 'Pakistan');

--------------------------------------------------------------------------------------------------------------------------------------------------
BETWEEN:
SELECT * FROM person WHERE date_of_birth BETWEEN '2023-01-01' AND '2023-01-1';
SELECT * FROM products WHERE price BETWEEN 50 AND 100;

--------------------------------------------------------------------------------------------------------------------------------------------------
LIKE:
In PostgreSQL (psql), both LIKE and ILIKE are operators used in a WHERE clause to perform pattern matching in strings. They are commonly used for searching and filtering based on a specified pattern. 

%: Represents zero or more characters.
SELECT email FROM person WHERE email LIKE '%amazon%';  [means any set of characters can be there before or after the word]

_: Represents a single character.


--------------------------------------------------------------------------------------------------------------------------------------------------
GROUP BY:
SELECT country_of_birth, COUNT(*) FROM person GROUP BY country_of_birth;
SELECT gender , COUNT(*) FROM person GROUP BY gender;
SELECT country_of_birth , COUNT(*) FROM person GROUP BY country_of_birth ORDER BY country_of_birth;   { For sorting the resulting grouped counted data}
--------------------------------------------------------------------------------------------------------------------------------------------------
GROUP BY HAVING:
SELECT country_of_birth , COUNT(*) FROM person GROUP BY country_of_birth HAVING COUNT(*) >5 ORDER BY COUNT(*);

--------------------------------------------------------------------------------------------------------------------------------------------------
MAX, MIN , AVG , ROUND, SUM:

SELECT MAX(price) FROM car;
SELECT MIN(price) FROM car;
SELECT AVGk(price) FROM car;
SELECT ROUND(AVG(price)) FROM car;

SELECT make , MAX(price) FROM car GROUP BY make;
SELECT make , ROUND(MAX(price)) FROM car GROUP BY make;

SELECT SUM(price) FROM car;
SELECT make , SUM(price) FROM car GROUP BY make;
--------------------------------------------------------------------------------------------------------------------------------------------------

ARITHMETIC operators:
% - + * % !

--------------------------------------------------------------------------------------------------------------------------------------------------
ALIAS : AS
In PostgreSQL (psql), you can use the AS keyword to assign aliases to columns or tables in your queries. Aliases provide alternative names for columns or tables, making the output more readable or simplifying the syntax of your SQL statements.

--------------------------------------------------------------------------------------------------------------------------------------------------
COALESCE:
 It is often used to handle situations where you want to retrieve the first non-null value from a list of expressions.

SELECT COALESCE(email , ' L  O  L' ) FROM person ;
SELECT COALESCE(email , 'NO email given' ) FROM person ;

--------------------------------------------------------------------------------------------------------------------------------------------------
NULLIF:
In PostgreSQL (psql), the NULLIF function is used to compare two expressions and return NULL if they are equal; otherwise, it returns the first expression. 

--------------------------------------------------------------------------------------------------------------------------------------------------

Date:
SELECT NOW();
SELECT NOW()::DATE;
SELECT NOW()::TIME;

addition and subtraction with date.
SELECT NOW() - INTERVAL '5 years';
SELECT NOW() - INTERVAL '10 MONTHS';

--------------------------------------------------------------------------------------------------------------------------------------------------
AGE:
SELECT * , AGE(NOW() , date_of_birth) AS age FROM person;

--------------------------------------------------------------------------------------------------------------------------------------------------
ALTER TABLE:

ALTER TABLE employee ADD COLUMN department VARCHAR(50);
ALTER TABLE employee DROP CONSTRAINT person_id;
ALTER TABLE employee ADD PRIMARY KEY(id);

RENAME TO:
ALTER TABLE current_table_name RENAME TO new_table_name;

--------------------------------------------------------------------------------------------------------------------------------------------------
UNIQUE CONSTRAINTS:

A UNIQUE constraint ensures that all values in a column or a set of columns are unique across the rows in a table.
It prevents duplicate values in the specified columns.

ALTER TABLE person ADD CONSTRAINT unique_email 	UNIQUE(email);


ALTER TABLE person DROP CONSTRAINT unique_email;

--------------------------------------------------------------------------------------------------------------------------------------------------
CHECK CONSTRAINTS:

A CHECK constraint is a rule applied to a column or set of columns in a table.
It ensures that the values in a column or set of columns meet specific conditions.

 ALTER TABLE person ADD CONSTRAINT gender_constraint 
 CHECK (gender != 'Male');

--------------------------------------------------------------------------------------------------------------------------------------------------

DELETE:
DELETE FROM person WHERE id = 1;
DELETE FROM person WHERE gender = 'Male' AND country_of_birth = 'England';

--------------------------------------------------------------------------------------------------------------------------------------------------
UPDATE:
UPDATE person SET email = 'nazim@gmail.com' WHERE id = 1011;

--------------------------------------------------------------------------------------------------------------------------------------------------
ON CONFLICT (id) DO NOTHING:
ON CONFLICT DO NOTHING clause is used in combination with the INSERT statement. It provides a way to handle conflicts that may arise due to violating a unique constraint or exclusion constraint during an insert operation.

--------------------------------------------------------------------------------------------------------------------------------------------------
ON CONFLICT (id) UPDATE SET : (UPSERT )

ON CONFLICT () UPDATE SET clause is used in PostgreSQL with the INSERT statement to handle conflicts by updating the existing row when a unique or exclusion constraint violation occurs. This is often used for upsert operations, where you want to insert a new row, but if a conflict arises, you update the existing row instead of raising an error.

for updating the conflicted values with the newly added values.
INSERT INTO person(id ,name , age , gender ) VALUES ( 1, 'nazim' , 88 , 'Male' ) ON CONFLICT (id) DO UPDATE SET email = EXCLUDED.email ;

--------------------------------------------------------------------------------------------------------------------------------------------------
Adding relation between tables:  Connecting two tables using foriegn key.
create table person (
    id BIGSERIAL NOT NULL PRIMARY KEY,
	first_name VARCHAR(50) NOT NULL,
	last_name VARCHAR(50) NOT NULL,
	gender VARCHAR(7) NOT NULL,
	email VARCHAR(100),
	date_of_birth DATE NOT NULL,
	country_of_birth VARCHAR(50) NOT NULL,

	car_id BIGINT REFERENCES car (id),				{car_id  =>  Foriegn Key}
	UNIQUE(car_id)
);

UPDATE person
SET car_id = 1
WHERE id = 1;

Here the person table is updated at the car_id with the id of car === 1

using foriegn keys to connect between two tables.

--------------------------------------------------------------------------------------------------------------------------------------------------
FORIEGN KEY :
A foreign key is a field in a relational database table that matches the primary key column of another table.
It establishes a link between the data in two tables, creating a parent-child relationship.

--------------------------------------------------------------------------------------------------------------------------------------------------

INNER JOIN: 

Effective way of combining two tables.
Inner join takes what is common in both tables and gives a new table.

SELECT * FROM person JOIN car ON person.car_id = car.id; 		{Joins car and person with car_id as the link }

SELECT person.first_name , car.make FROM person JOIN car ON person.car_id = car.id;
--------------------------------------------------------------------------------------------------------------------------------------------------
LEFT JOIN:

To join both tables including records which dont have a foriegn key relationship.

SELECT * FROM person LEFT JOIN car ON person.car_id = car.id; 

--------------------------------------------------------------------------------------------------------------------------------------------------
DELETEING RECORDS WITH FORIEGN KEYS:

first we need to remove the foriegn key relation.
So we have to delete the record from the person then from the car.
--------------------------------------------------------------------------------------------------------------------------------------------------
EXPORTING QUERY RESULT TO CSV:

\copy (SELECT * FROM person LEFT JOIN car ON car.id = person.car_id) TO '/Users/muham/downloads/result.csv' DELIMITER ',' CSV HEADER;

--------------------------------------------------------------------------------------------------------------------------------------------------
IDEMPOTENT COMMAND :
Execute many times but only have an effect once.

--------------------------------------------------------------------------------------------------------------------------------------------------
using extension in postgreSQL:

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

--------------------------------------------------------------------------------------------------------------------------------------------------

GENERATING A UUID:
SELECT uuid_generate_v4();

--------------------------------------------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------------------------------------------------------
							D O C U M  E N T S :
--------------------------------------------------------------------------------------------------------------------------------------------------

SELECT: To retrieve data from tables. (Statement)

https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-select/

 
1.DISTINCT : Select distinct rows using DISTINCT operator.

2.ORDER BY : To sort the rows of the result set we use ORDER BY clause.
	The LENGTH() function accepts a string and returns the length of that string.
	NULLS LAST { for orderong null values at the last}

3.WHERE : To filter rows returned by a SELECT statement.
	you place the WHERE clause right after the FROM clause of the SELECT statement. 
	1. IN: The IN operator allows you to check whether a value matches any value in a list of values.
		
		Cast Operator: :: To convert a value of one type into another.
			SELECT 
  			CAST ('100' AS INTEGER);

	2. NOT IN: The NOT IN operator returns true if the value is not equal to any value in the list  
	3. BETWEEN : To check if a value falls within a range of values.   /  NOT BETWEEN : To check if a value does not fall within a range of values.
	4. LIKE / NOT LIKE / ILIKE / NOT ILIKE
	5.IS NULL : operator to check whether a value is NULL or not.

3.LIMIT :  Constrains the number of rows returned by the query.
	OFFSET : To skip values or rows.

4.FETCH: To retrieve a portion of rows returned by a query.
	Syntax : FETCH FIRST 5 ROW ONLY;
	SELECT * FROM person FETCH FIRST 5 ROW ONLY OFFSET 2;

5. GROUP BY : TO divide rows into groups. UPSERT
	HAVING : Often used with the GROUP BY clause to filter groups based on a specified condition.

--------------------------------------------------------------------------------------------------------------------------------------------------

JOIN : join is used to combine columns from one or more tables based on the values of the common columns between related tables. The common columns are typically the primary key columns of the first table and the foreign key columns of the second table. 
Join with other tables using joins such as INNER JOIN, LEFT JOIN, FULL OUTER JOIN, CROSS JOIN clauses.
Perform set operations using UNION, INTERSECT, and EXCEPT.
--------------------------------------------------------------------------------------------------------------------------------------------------

UNION:  operator to combine result sets of multiple queries into a single result set.
	SELECT name FROM person UNION SELECT model FROM car;

UNION ALL: The UNION operator removes all duplicate rows from the combined data set. To retain the duplicate rows, you use the the UNION ALL instead.
	SELECT name FROM person UNION ALL SELECT model FROM car;

Use the UNION to combine result sets of two queries and return distinct rows.
Use the UNION ALL to combine the result sets of two queries but retain the duplicate rows.

--------------------------------------------------------------------------------------------------------------------------------------------------
INTERSECT:  The INTERSECT operator returns a result set containing rows that are available in both result sets.
	  SELECT name FROM person INTERSECT SELECT model FROM car;

Except – return the rows in the first query that does not appear in the output of the second query.
--------------------------------------------------------------------------------------------------------------------------------------------------

GROUPING SETS:
SELECT
    region,
    product,
    SUM(sales_amount) AS total_sales
FROM
    sales
GROUP BY
    GROUPING SETS ((region, product), (region), ());

To get a group of allhtese combinations specified and their sum .

This query is much shorter and more readable. In addition, PostgreSQL will optimize the number of times it scans the sales table and will not scan multiple times.

Grouping the data into multiple groups in a single query .

TO specify multiple grouping sets in a single query.


Grouping function
The GROUPING() function accepts an argument which can be a column name or an expression:

ROLLUP:
Rollup operators let you extend the functionality of GROUP BY by calculating subtotal and grand totals. 
 SELECT region, product, SUM(sales_amount) AS total_sales FROM sales GROUP BY ROLLUP (region , product);

CUBE:
Is similar to the ROLLUP but the CUBE Operator can calculate the subtotal and grand total of all permutation of the columns specified.
SELECT
    region,
    product,
    month,
    SUM(amount) AS total_amount
FROM
    sales
GROUP BY
    CUBE (region, product, month);


https://www.youtube.com/watch?v=daiKHQn4CdI   - CUBE

--------------------------------------------------------------------------------------------------------------------------------------------------

Subquery: A subquery is a query nested within another query.  (Inner query ) 
	A subquery can be useful for retrieving data that will be used by the main query as a condition for further data selection.

	Can be executed independently of the outer query.
	It is executed once, and its result is used by the outer query to perform the main query.

 SELECT * FROM sales WHERE region = (SELECT region FROM sales WHERE sales_amount = 1000.50);


Correlated Subquery:
To perform a query that depends on the values of the current row being processed.
	Subquery that is dependent on the outer query. 
	Correlated subqueries are typically used when you need to compare values with each row in the outer query.

In a correlated subquery, there is a reference to the outer query within the subquery

ANY:  To compare a scalar value with a set of values returned by a subquery.
 	SELECT * FROM sales WHERE product = ANY(ARRAY['Product_A','Product_B']);
	 SELECT * FROM sales WHERE product = ANY( SELECR product FROM sales);

ALL: The ALL operator returns true if the comparison is true for all values returned by the subquery.
	SELECT * FROM employees WHERE salary < ALL ( SELECT salary FROM managers );

EXISTS :Is used to check the existence of rows in the result set of a subquery.
	
SELECT CustomerName
FROM Customers c
WHERE EXISTS (
    SELECT 1
    FROM Orders o
    WHERE o.CustomerID = c.CustomerID
);

The primary purpose of the EXISTS operator is to check whether a subquery returns at least one row. If the subquery result set is not empty (i.e., it returns one or more rows), then the EXISTS operator evaluates to true. On the other hand, if the subquery result set is empty, it evaluates to false.
--------------------------------------------------------------------------------------------------------------------------------------------------

Common table expression (CTE):
A CTE helps you enhance the readability of a complex query by breaking it down into smaller and more reusable parts.

 A Common Table Expression (CTE) is like creating a special group of data in a query. You give this group a name, and then you can use that name in your query to easily work with that specific set of data. It's like making a mini-table within your query for a specific purpose.

You can use this mini-table as if it's a real table in your database, and it's available for the duration of that query. Once the query is done, this special group (CTE) goes away.

WITH cte_name (column1, column2, ...) AS (
    -- CTE query definition
    SELECT column1, column2, ...
    FROM your_table
    WHERE your_conditions
)
-- Main query that references the CTE
SELECT *
FROM cte_name;



REAL EG:

WITH RegionTotalSales AS (
    SELECT
        region,
        SUM(sales_amount) AS total_sales
    FROM
        sales
    GROUP BY
        region
)

-- Query using the CTE
SELECT
    region,
    total_sales
FROM
    RegionTotalSales;
--------------------------------------------------------------------------------------------------------------------------------------------------

INSERT:

INSERT INTO table1(column1, column2, …)
VALUES (value1, value2, …)
RETURNING *;


UPDATE JOIN:
This is particularly useful when you need to update values in a table using information from another related table. 
To update data in a table based on values in another table.


	UPDATE employees
	SET salary = salary_updates.new_salary
	FROM salary_updates
	WHERE employees.employee_id = salary_updates.employee_id;


UPSERT:
Combination of update and insert.
The upsert allows you to update an existing row or insert a new one if it doesn’t exist.

INSERT ..... ON CONFLICT (id)  DO UPDATE SET email = EXCLUDED.email;

--------------------------------------------------------------------------------------------------------------------------------------------------

TRANSACTION:

A database transaction is a single unit of work that consists of one or more operations.

A classical example of a transaction is a bank transfer from one account to another. A complete transaction must ensure a balance between the sender and receiver accounts. It means that if the sender account transfers X amount, the receiver receives X amount, no more or no less.

A PostgreSQL transaction is atomic, consistent, isolated, and durable.


These properties are often referred to as ACID:

* Atomicity guarantees that the transaction is completed in an all-or-nothing manner.
	This property ensures that a transaction is treated as a single, indivisible unit of work. Either all the changes made in a transaction are committed to the database, or none of them are. If any part of the transaction fails, the entire transaction is rolled back to its original state, ensuring that the database remains in a consistent state.


* Consistency :
ensures the change to data written to the database must be valid and follow predefined rules.
The database must satisfy a set of integrity constraints both before and after the transaction. If a transaction violates any integrity constraints, it is rolled back, maintaining the overall consistency of the database.


* Isolation :
	To convert parallel schedule to serial schedudle.
	Isolation ensures that the execution of one transaction is isolated from the execution of other transactions. Even if multiple transactions are executing concurrently


* Durability makes sure that transactions that have been committed will be stored in the database permanently. Chenges will be permanent till next change.
	, its effects on the database persist even in the event of a system failure



1.BEGIN:
 Is often used to mark the beginning of a transaction block in many SQL databases.

2.Commit:

The COMMIT statement is used to permanently save the changes made during a transaction.
Once a transaction is committed, the changes become permanent and cannot be undone.
To make the change visible to other sessions (or users) you need to commit the transaction by using the COMMIT
COMMIT;

3.Rollback:

The ROLLBACK statement is used to undo the changes made during a transaction.
If any error occurs during the transaction or if there is a need to discard the changes for any reason, the ROLLBACK statement can be executed.
It is important to note that after a rollback, the database state is restored to what it was before the transaction started.

--------------------------------------------------------------------------------------------------------------------------------------------------

Data Types:
1. Boolean : 

2.Character
 	CHAR(n) : It is used to store characters with specifc fixed lenght. If less it adds spaces as padding . If greater than n it shows an error.
 	VARCHAR(n) :  It is a variable-length character string. The VARCHAR(n) allows you to store up to n characters.
 	TEXT : Unlimited length character string.

3. Numeric:
	integer => SMALLINT (2-byte signed integer)
		   INT ( 4-byte signed integer) 
		   Serial is the same as integer except that PostgreSQL will automatically generate and populate values into the SERIAL column. 

		   numeric(p,s)   real number with p digits with s number after the decimal point. 

4.Temporal data types:
	DATE stores the dates only.
	TIME stores the time of day values.
	TIMESTAMP stores both date and time values.
	TIMESTAMPTZ is a timezone-aware timestamp data type. It is the abbreviation for timestamp with the time zone.
	INTERVAL stores periods.		

5.Arrays:
In PostgreSQL, you can store an array of strings, an array of integers, etc., in array columns

6.JSON data types: 
The JSON data type stores plain JSON data that requires reparsing for each processing, while JSONB data type stores JSON data in a binary format which is faster to process but slower to insert.
 In addition, JSONB supports indexing, which can be an advantage.

7.UUID: 
The UUID values guarantee a better uniqueness than SERIAL and can be used to hide sensitive data exposed to the public such as values of id in URL.

--------------------------------------------------------------------------------------------------------------------------------------------------

Column constraints: 
The column constraints include primary key, foreign key, not null, unique, check, and default.

NOT NULL – ensures that the values in a column cannot be NULL.
UNIQUE – ensures the values in a column are unique across the rows within the same table.
PRIMARY KEY – a primary key column uniquely identifies rows in a table. A table can have one and only one primary key. The primary key constraint allows you to define the primary key of a table.
CHECK – ensures the data must satisfy a boolean expression. For example, the value in the price column must be zero or positive.
FOREIGN KEY – ensures that the values in a column or a group of columns from a table exist in a column or group of columns in another table. Unlike the primary key, a table can have many foreign keys.

--------------------------------------------------------------------------------------------------------------------------------------------------

SELECT INTO:
SELECT INTO statement to create a new table from the result set of a query.
 SELECT region , product INTO newTable FROM sales;

 SELECT * FROM newTable;
 region |  product
--------+-----------
 North  | Product_A
 North  | Product_B
 South  | Product_A
 South  | Product_B
 East   | Product_A
 East   | Product_B
 West   | Product_A
 West   | Product_B


SELECT username, email
INTO new_users
FROM old_users
WHERE status = 'active';
--------------------------------------------------------------------------------------------------------------------------------------------------

CREATE TABLE AS:
CREATE TABLE AS statement to create a new table from the result of a query.
 CREATE TABLE sales2 AS SELECT region,sales_amount FROM sales;

--------------------------------------------------------------------------------------------------------------------------------------------------
SERIAL : 
In PostgreSQL, the SERIAL data type is used to create an auto-incrementing column, often used as a primary key. When a column is defined as SERIAL, PostgreSQL automatically generates unique integer values for that column.

SMALLSERIAL : 2 bytes
SERIAL : 4 bytes
BIGSERIAL : 8 bytes


--------------------------------------------------------------------------------------------------------------------------------------------------

NORMALIZATION:

Normalization is a database design technique used to organize and structure relational database tables to reduce redundancy and dependency. The primary goal of normalization is to eliminate data anomalies, such as update, insertion, and deletion anomalies, and to ensure that the database remains in a consistent and efficient state. It involves breaking down large, complex tables into smaller, more manageable tables, while maintaining data integrity.

1NF , 2NF , 3NF , Boyce COdd NF

1.First Normal Form (1NF): Ensures that each column in a table contains atomic (indivisible) values, and there are no repeating groups or arrays. It eliminates duplicate rows and ensures that each cell contains a single piece of information.

2. Second Normal Form (2NF): A table is in 2NF if it is in 1NF and there is no partial dependencies in the table.

3.Third Normal Form (3NF): By  removing transitive dependencies from 2NF.

4.Boyce-Codd Normal Form (BCNF) : Stricter form of 3NF.

--------------------------------------------------------------------------------------------------------------------------------------------------

CONSTRAINTS:
UNIQUE , AUTO_INCREMENT , PRIMARY KEY , NOT NULL

--------------------------------------------------------------------------------------------------------------------------------------------------

RELATIONSHIPS:
ONE-TO-MANY  , MANY-TO-MANY , ONE-TO-ONE 
In PostgreSQL (psql), relationships between tables are established through the use of foreign keys. A foreign key is a field in a table that refers to the primary key in another table. This creates a link between the two tables, enforcing referential integrity and allowing you to establish relationships between them.
--------------------------------------------------------------------------------------------------------------------------------------------------
JOINS:

INNER JOIN:
The INNER JOIN keyword selects records that have matching values in both tables.
SELECT employees.employee_id, employees.employee_name, departments.department_name
FROM employees
INNER JOIN departments ON employees.department_id = departments.department_id;

LEFT JOIN:
The LEFT JOIN keyword returns all records from the left table (employees), and the matched records from the right table (departments). 

RIGHT JOIN:
The RIGHT JOIN keyword returns all records from the right table (departments), and the matched records from the left table (employees). 

FULL JOIN:
The FULL JOIN returns all the records from the left and right tables even if they are matched or not.

--------------------------------------------------------------------------------------------------------------------------------------------------
3 SCHEMA ARCHITECTURE:

3 Schema architecture is a conceptual framework used in database design.It separates the database design into 3 components where each handling a specific function of the data management.

The 3-schema architecture helps in separating the concerns related to how data is stored physically, how it is logically organized, and how it is presented to different users or applications. This separation provides flexibility and scalability in managing databases.

The three schemas are 
1.USER SCHEMA(external schema) 
	This is the schema which the end users interact with. It represents the way data is shown to the external groups or users.

2.Logical schema (conceptual schema)
	This schema deals with the entire logical structure of the database. It represents the data model , constraints , relationships.

3.Physical schema (internal schema)
	This is the lowest level of abstraction and represents how data is physically stored and accessed on the storage devices.
Includes details about indexing, storage structures, and access paths.

 --------------------------------------------------------------------------------------------------------------------------------------------------
INDEXING:
Indexing is a database optimization technique used to improve the speed and efficiency of query performance by providing a faster way to retrieve data. An index is a data structure that allows the database management system (DBMS) to locate and access the rows in a table quickly based on the values in one or more columns. 

The index consists of key columns and pointers to the actual rows in the table.

Single-Column Index: Created on a single column.
Composite Index: Created on multiple columns. Useful when queries involve multiple columns in the WHERE clause or for optimizing JOIN operations.
Unique Index: Ensures that values in the indexed column(s) are unique across the table.
	Clustered Index: Determines the physical order of data in the table. In PostgreSQL, the primary key constraint creates a clustered index.
	Non-Clustered Index: The default index type in PostgreSQL, where the data rows and the index are stored separately.

Use indexing on columns that are frequently used in WHERE clauses or JOIN conditions.

--------------------------------------------------------------------------------------------------------------------------------------------------
AGGREGATE FUNCTIONS IN PSQL:
COUNT(),SUM(),MAX(),MIN(),AVG(),GROUP BY , HAVING

--------------------------------------------------------------------------------------------------------------------------------------------------

SCALAR FUNCTIONS:
Scalar functions in PostgreSQL (psql) are functions that operate on individual values and return a single result. Unlike aggregate functions, which operate on sets of values to produce a single result for each set, scalar functions work on a row-by-row basis. 

1.Mathematical Functions:

ABS(): Returns the absolute value of a number.
CEIL() / CEILING(): Rounds a number up to the nearest integer.
FLOOR(): Rounds a number down to the nearest integer.         SELECT FLOOR(4.7) AS floored_number;
ROUND(): Rounds a number to a specified number of decimal places.

2.String Functions:

LENGTH() / CHAR_LENGTH(): Returns the length of a string.
LOWER(): Converts a string to lowercase.                      SELECT LOWER('Hello, World!') AS lower_text;
UPPER(): Converts a string to uppercase.
SUBSTRING(): Extracts a substring from a string.
	SELECT SUBSTRING('abcdefgh' FROM 3 FOR 4);

3.Date and Time Functions:
	
NOW(): Returns the current date and time.

4.Type Conversion Functions:

CAST(): Converts one data type to another.

--------------------------------------------------------------------------------------------------------------------------------------------------

FORIEGN KEYS AND PRIMARY KEYS:

CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    employee_name VARCHAR(100) NOT NULL,
    department_id INT REFERENCES departmentsTable(id)
);

CREATE TABLE departments (
    id SERIAL PRIMARY KEY,
    department_name VARCHAR(50) NOT NULL
);

The combination of primary and foreign key constraints helps maintain referential integrity between related tables in a PostgreSQL database. It ensures that relationships between tables are well-defined and that data consistency is maintained.

--------------------------------------------------------------------------------------------------------------------------------------------------

Savepoints:
In transactions we can save our progress in the current transaction by which we can rollback till that savepoint in a transaction.

SAVEPOINT savepointNAme;
--------------------------------------------------------------------------------------------------------------------------------------------------

DML, DDL, DCL:
To categorize different types of SQL (Structured Query Language) commands.

DML:DATA MANIPULATION LANGUAGE 
	DML deals with the manipulation of data stored in the database.
	 SELECT, INSERT, UPDATE, DELETE.

DDL: Data definition langauge
	DDL is concerned with defining and managing the structure of the database.
	CREATE , DROP ,ALTER , 

DCL: Data control language
	DCL is focused on controlling access to data through permissions and privileges.
	GRANT , REVOKE

--------------------------------------------------------------------------------------------------------------------------------------------------
TRUNCATE:
TRUNCATE command is used to quickly delete all rows from a table and free the space occupied by the table

--------------------------------------------------------------------------------------------------------------------------------------------------
PL ( procedural language ):
 It allows you to write procedural code, such as functions, stored procedures, and triggers, within the database.
PL is used when you need more complex logic or business rules that go beyond the capabilities of standard SQL. It enables you to encapsulate business logic within the database itself.

--------------------------------------------------------------------------------------------------------------------------------------------------
SEQUALIZE:
Popular object-relational-Mapping library for Node.js that provides a set of tools to work with relational database sysytems.Sequelize simplifies database interactions by allowing developers to use JavaScript (with Promises or async/await) instead of raw SQL queries.

--------------------------------------------------------------------------------------------------------------------------------------------------

 DEADLOCK:
In PostgreSQL, a deadlock occurs when two or more transactions are blocked, each waiting for the other to release a lock, resulting in a circular waiting scenario. PostgreSQL has built-in mechanisms to detect and resolve deadlocks automatically. 

Situation when 2 or more transactions are waiting for one another to give up locks.

--------------------------------------------------------------------------------------------------------------------------------------------------
